**Виконала студентка групи ІКМ-М223в Данилко Вікторія Миколаївна**  

**Мова програмування:** Python  
**Що виконує код:** міні-гру "Камінь, ножиці, папір"


**АНАЛІЗ:**  
В першому файлі [lab_1_input.py](https://github.com/danny-are-you-crazy/arch.sol-LAB/new/main/lab_1/lab_1_input.py) є проблема довгого методу, а саме:  
1. **Велика довжина головного методу *play_game*,** в якому 20 строчок коду. Довжина методу більше 10 рядків повинна 
починати турбувати, але іноді можуть бути виключення, но не в цьому випадку.
2. **Занадто багато різних дій в одному методі**. А саме:
   * введення даних: і від цього залежить вихід з гри чи обирання варіанту і продовження гри (зчитування коду далі),
   * перевірка правил гри за результатами вибора гравця і рандома комп'ютера
   * виведення результата
3. **Додавання нових правил гри може бути складним**
4. **Спагеті-код**. На початку умовні конструкції змішуються з обробкою введення користувача, що робить код важким для розуміння.
     > user_choice = input("Напишіть ваш вибір (камінь, ножиці, папір) або напишіть 'вихід' щоб вийти: ").lower()

**ЯКІ ІСНУЮТЬ МЕТОДИ "ЛІКУВАННЯ":**  
1. Для скорочення тіла методу досить застосувати відокремлення методу.
2. Якщо локальні змінні і параметри перешкоджають виділенню методу, можна застосувати заміну тимчасової змінної 
викликом методу, заміну параметрів об’єктом і передачу всього об’єкта.
3. Можна спробувати виділити весь метод в окремий об’єкт за допомогою заміни методу об’єктом методів.

**ПРИЙНЯТІ РІШЕННЯ ЩОДО РЕФАКТОРИНГУ:**  
Було вирішено, що для такого коду буде достатньо ефективно використовувати пункт 1 "відокремлення методу". 
Пункт 2 не потрібний, так як в коді немає локальних змінних котрі можна замінити і т.д. 
1. **Було відокремлено методи отримання вибору користувача та комп'ютера.** Були створені два окремих методи: 
*get_user_choice()* та *get_computer_choice()*, які відповідають за отримання вибору користувача та комп'ютера відповідно. 
2. **Відокремлення логіки визначення переможця.** Було перенесено в окремий метод determine_winner.
3. **Створення методу для завершення гри.** Раніше завершення гри описувалось на початку коду, але тепер відокремлена у метод end_game 
та розташовано в кінці, що логічно.  
  
Результат можна побачити в [lab_2_output.py](https://github.com/danny-are-you-crazy/arch.sol-LAB/new/main/lab_1/lab_2_output.py)

.........  
**ВИСНОВОК (Мабуть не обов'язковий, но цей момент є в завданні)**  
Результати тестування оновленого методу та зіставлення з оригінальним:
1. Під час тестування довгого оригінального коду, який не використовує модульний підхід, важко визначити, де саме можуть бути проблеми чи помилки.
Даже не дивлячись на те, що там використовувались коментарі, було складно розібратись, так як там не було логіки. Страшно міняти код, бо може прийдеться
переписувати всі інші змінні та ін.
2. Після рефакторингу коду, коли логіка розділена на окремі методи, тестування стає простішим. Перевірка коду власноруч зрозуміліша, визиває менше стресу
при думці, що прийдеться щось дописувати або міняти.

Оцінка отриманих покращень та їх вплив на архітектуру системи:
1. Модульність. Розділення коду на окремі методи робить кожен етап гри (отримання вибору гравця, отримання вибору комп'ютера, визначення переможця тощо) 
модульними та незалежними один від одного. Це полегшує розуміння коду та дозволяє змінювати або розширювати функціональність без зміни інших частин коду.
2. Читабельність. Використання окремих методів для кожного кроку гри робить код більш зрозумілим та читабельним. Кожен метод відповідає конкретному етапу гри, що полегшує зрозуміння його функціональності.
3. Розширюваність. Розділення коду на окремі методи робить його більш гнучким та легше розширюваним. Нові можливості, я не знаю... ну, наприклад, добавляння
четвертого предмету "криниця" або другого комп'ютера, впровадити буде легше із-за зрозумілості коду.
